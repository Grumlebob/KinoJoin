<div class="mb-2 flex justify-between">
    <!-- CinemaLocation -->
    <h3 id="@Cinema.Id" class="text-xl font-bold mb-2.5">@Cinema.Name</h3>
    <button @onclick="ToggleCollapse">
        <svg class="transition-transform" style="@(_shouldRender ? "transform: rotate(0deg);" : "transform: rotate(-180deg);")" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 20 20" fill="currentColor">
            <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
        </svg>
    </button>
</div>

@if (!_shouldRender)
{
    return;
}

    @foreach (var showtimesByVersionTag in ShowtimesByCinema.GroupBy(s => s.VersionTag.Id))
    {
        var versionTag = showtimesByVersionTag.First().VersionTag;
        <div class="mb-4 max-w-screen-md">
            <!-- Version -->
            <div class="w-fit">
                <p class="bg-gray-200 px-2 py-1 font-label">@versionTag.Type</p>
            </div>
            <!-- Showtimes -->
            <div class="overflow-x-auto">
                <table class="border-collapse">
                    <tr>
                        @{
                            // Determine the start and end dates of the interval
                            var startDate = Showtimes.Min(s => s.Playtime.StartTime.ToLocalTime());
                            var endDate = Showtimes.Max(s => s.Playtime.StartTime.ToLocalTime());

                            var latestDateForSpecificCinemaVersion = Showtimes.Where(s => s.Movie.Id == ShowtimesByMovie.Key && s.Cinema.Id == ShowtimesByCinema.Key && s.VersionTag.Id == showtimesByVersionTag.Key).Max(s => s.Playtime.StartTime.ToLocalTime().Date);

                            // Loop through each date in the interval
                            for (var date = startDate.Date; date <= endDate.Date && date <= latestDateForSpecificCinemaVersion.Date; date = date.AddDays(1))
                            {
                                <th class="w-10 overflow-hidden text-ellipsis whitespace-nowrap border-b border-gray-200 p-2 text-left align-top">@date.ToString("dd. MMM")</th>
                            }
                        }
                    </tr>
                    <tr>
                        <!-- Create table data for each showtime within the grouped date -->
                        @for (var date = startDate.Date; date <= endDate.Date && date <= latestDateForSpecificCinemaVersion.Date; date = date.AddDays(1))
                        {
                            //Check if it exists if not, else
                            @if (Showtimes.Any(s => s.Movie.Id == ShowtimesByMovie.Key && s.Cinema.Id == ShowtimesByCinema.Key && s.VersionTag.Id == showtimesByVersionTag.Key && s.Playtime.StartTime.ToLocalTime().Date == date))
                            {
                                <td class="p-2 align-top">
                                    @foreach (var showtime in Showtimes.Where(s => s.Movie.Id == ShowtimesByMovie.Key && s.Cinema.Id == ShowtimesByCinema.Key && s.VersionTag.Id == showtimesByVersionTag.Key && s.Playtime.StartTime.ToLocalTime().Date == date))
                                    {
                                        var vote = Votes.First(v => v.ShowtimeId == showtime.Id);
                                        <div id="@showtime.Id" class="w-24 h-16 max-h-16 p-1 mb-1 flex flex-col items-center justify-center cursor-pointer select-none rounded shadow-inset bg-@vote.SelectedOption.Color hover:border hover:border-gray-300" value="@showtime.Playtime.StartTime.ToLocalTime()" @onclick="@(() => HandleShowtimeClick(vote))">
                                            <div class="mb-1 text-center text-sm line-clamp-1">@showtime.Room.Name</div>
                                            <div class="text-lg font-bold">@showtime.Playtime.StartTime.ToLocalTime().ToString("HH:mm")</div> <!-- showtime-time -->
                                        </div>
                                    }
                                </td>
                            }
                            else
                            {
                                <!-- empty-showtime -->
                                <td class="p-2 align-top">
                                    <div class="mb-1 h-16 max-h-16 w-24 rounded p-1 shadow-inset empty-showtime">
                                    </div>
                                </td>
                            }
                        }
                    </tr>
                </table >
            </div >
        </div>
    }


@code {

    [Parameter] public List<Showtime> Showtimes { get; set; }

    [Parameter] public Cinema Cinema { get; set; }

    [Parameter] public IGrouping<int, Showtime> ShowtimesByCinema { get; set; }

    [Parameter] public IGrouping<int, Showtime> ShowtimesByMovie { get; set; }

    [Parameter] public ICollection<ParticipantVote> Votes { get; set; } = [];

    [Parameter] public List<SelectOption> SelectOptions { get; set; } = [new SelectOption() { VoteOption = "Kan ikke", Color = "gray-200" }, new SelectOption() { VoteOption = "Kan godt", Color = "success" }];

    [Parameter] public EventCallback<ICollection<ParticipantVote>> VotesChanged { get; set; }

    private bool _hasChanged = false;
    
    private bool _shouldRender = true;
    
    private void ToggleCollapse()
    {
        _shouldRender = !_shouldRender;
        _hasChanged = true;
        StateHasChanged();
    }

    private async Task HandleShowtimeClick(ParticipantVote voteToIncrement)
    {
        //find index of select option in order to increment it
        var next = (SelectOptions.FindIndex(
                       s => (s.VoteOption, s.Color) == (voteToIncrement.SelectedOption.VoteOption, voteToIncrement.SelectedOption.Color)) + 1)
                   % SelectOptions.Count;
        voteToIncrement.SelectedOption = SelectOptions[next];
        voteToIncrement.SelectedOptionId = SelectOptions[next].Id;

        await VotesChanged.InvokeAsync(Votes);
        _hasChanged = true;
    }

    protected override bool ShouldRender()
    {
        if (!_hasChanged) return false;
        _hasChanged = false;
        return true;
    }

}
